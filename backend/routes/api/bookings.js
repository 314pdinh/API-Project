const express = require('express');
const { requireAuth } = require('../../utils/auth');
const router = express.Router();
const { Op } = require('sequelize');
const { Spot, Review, SpotImage, User, Booking, sequelize, ReviewImage } = require('../../db/models');

// Get all of the Current User's Bookings
router.get('/current', requireAuth, async (req, res) => {
  const { user } = req;

  const allBookings = await Booking.findAll({
      where: {
          userId: user.id
      }, 
      include : [{
          model: Spot,
          attributes: ['id', 'ownerId', 'address', 'city', 'state', 'country', 'lat', 'lng', 'name', 'price'],
          include: [
              { 
                model: SpotImage,
                as: "previewImage",
                attributes: [ "url" ],
                where: { preview: true },
                required: false,
              }
          ]
      }]
  })

  const newArra = allBookings.map(booking => {
    const { Spot } = booking;
    const previewImage = Spot?.SpotImages?.[0]?.url || null;
    delete Spot?.SpotImages;
    Spot.previewImage = previewImage;
    return booking.toJSON();
  });
  
  return res.status(200).json({ Bookings: newArra });
})

  
  

// Edit a Booking
router.put('/:bookingId', requireAuth, async (req, res) => {
    const { user } = req;
    const { startDate, endDate } = req.body;    
    const booking = await Booking.findByPk(req.params.bookingId);
    const startDay = new Date(startDate);
    const lastDay = new Date(endDate);
    const comment = { message: "Sorry, this spot is already booked for the specified dates", errors: {} };

    if(!booking){
        return res.status(404).json({ message: "Booking couldn't be found" });
    }
    if(booking.userId !== user.id){
        return res.status(403).json({ message: "Authenticated user does not have the correct role(s) or permission(s)" });
    }
    if(lastDay < startDay){
        return res.status(400).json({
            message: "Bad Request", // (or "Validation error" if generated by Sequelize),
            errors: {
              endDate: "endDate cannot come before startDate"
            }
        });
    }

    const now = new Date();
    if(startDay.getTime() < now.getTime() || lastDay.getTime() < now.getTime()){
        return res.status(403).json({
            message: "Past bookings can't be modified"
        });
    }

    const bookings = await Booking.findAll({
        where: { spotId: booking.spotId }
    });

    bookings.forEach(booking => {
        if (booking.startDate.getTime() <= startDay.getTime() && booking.endDate.getTime() >= startDay.getTime()) {
            comment.errors.startDate = "Start date conflicts with an existing booking";
        }
        if (booking.endDate.getTime() >= lastDay.getTime() && booking.startDate.getTime() <= lastDay.getTime()) {
            comment.errors.endDate = "End date conflicts with an existing booking";
        }
    });

    if (Object.keys(comment.errors).length) {
        return res.status(403).json(error);
    }

    if(startDay){
        booking.startDate = startDay;
    }
    if(lastDay){
        booking.endDate = lastDay;
    }
    
    // assign to coresponding properties 
    const scheduleDates = {
        id: booking.id,
        spotId: booking.spotId,
        userId: user.id,
        startDate: startDate,
        endDate: endDate,
        createdAt: booking.createdAt,
        updatedAt: booking.updatedAt
    };
    await booking.save();
    return res.status(200).json(scheduleDates);
});

// Delete a Booking
router.delete('/:bookingId', requireAuth, async (req, res) => {
    const { user } = req;
    const bookingId = await Booking.findByPk(req.params.bookingId, {
      include: {
        model: Spot,
      }
    });

    if (!bookingId) { 
        return res.status(404).json({ message: "Booking couldn't be found" })
    }

    if(bookingId.userId !== user.id && bookingId.Spot.ownerId !== user.id) { return res.status(403).json({ message: "Authenticated user does not have the correct role(s) or permission(s)" })};
    
    const today = new Date();
    if(bookingId.startDate <= today) {
        return res.status(403).json({ "message": "Bookings that have been started can't be deleted" })
    }
    
    await bookingId.destroy();
    return res.status(200).json({ message: 'Successfully deleted' })

})

module.exports = router;